#!/usr/bin/perl
#===============================================================================
#
#         FILE:  gosa-sd
#
#        USAGE:  ./gosa-sd
#
#  DESCRIPTION:
#
#      OPTIONS:  ---
# REQUIREMENTS:  libconfig-inifiles-perl libcrypt-rijndael-perl libxml-simple-perl 
#                libdata-dumper-simple-perl libdbd-sqlite3-perl libnet-ldap-perl
#                libpoe-perl
#         BUGS:  ---
#        NOTES:
#       AUTHOR:   (Andreas Rettenberger), <rettenberger@gonicus.de>
#      COMPANY:
#      VERSION:  1.0
#      CREATED:  12.09.2007 08:54:41 CEST
#     REVISION:  ---
#===============================================================================

use strict;
use warnings;
use Getopt::Long;
use Config::IniFiles;
use POSIX;

use Fcntl;
use IO::Socket::INET;
use IO::Handle;
use IO::Select;
use Symbol qw(qualify_to_ref);
use Crypt::Rijndael;
use MIME::Base64;
use Digest::MD5  qw(md5 md5_hex md5_base64);
use XML::Simple;
use Data::Dumper;
use Sys::Syslog qw( :DEFAULT setlogsock);
use Cwd;
use File::Spec;
use GOSA::DBsqlite;
use POE qw(Component::Server::TCP);

my $modules_path = "/usr/lib/gosa-si/modules";
use lib "/usr/lib/gosa-si/modules";

my (%cfg_defaults, $foreground, $verbose, $ping_timeout);
my ($bus, $msg_to_bus, $bus_cipher);
my ($server, $server_mac_address, $server_events);
my ($gosa_server, $job_queue_timeout, $job_queue_table_name, $job_queue_file_name,$job_queue_loop_delay);
my ($known_modules, $known_clients_file_name, $known_server_file_name);
my ($max_clients);
my ($pid_file, $procid, $pid, $log_file);
my (%free_child, %busy_child, $child_max, $child_min, %child_alive_time, $child_timeout);
my ($arp_activ, $arp_fifo, $arp_fifo_path);
my ($xml);

# variables declared in config file are always set to 'our'
our (%cfg_defaults, $log_file, $pid_file, 
    $bus_activ, $bus_passwd, $bus_ip, $bus_port,
    $server_activ, $server_ip, $server_port, $SIPackages_key, $max_clients,
    $arp_activ, $arp_fifo_path,
    $gosa_activ, $GosaPackages_key, $gosa_ip, $gosa_port, $gosa_timeout,
);

# additional variable which should be globaly accessable
our $server_address;
our $bus_address;
our $gosa_address;
our $no_bus;
our $no_arp;
our $verbose;
our $forground;
our $cfg_file;

# specifies the verbosity of the daemon_log
$verbose = 0 ;

# if foreground is not null, script will be not forked to background
$foreground = 0 ;

# specifies the timeout seconds while checking the online status of a registrating client
$ping_timeout = 5;

$no_bus = 0;

$no_arp = 0;

# name of table for storing gosa jobs
our $job_queue_table_name = 'jobs';
our $job_db;

# holds all other gosa-sd as well as the gosa-sd-bus
our $known_server_db;

# holds all registrated clients
our $known_clients_db;

%cfg_defaults =
("general" =>
    {"log_file" => [\$log_file, "/var/run/".$0.".log"],
    "pid_file" => [\$pid_file, "/var/run/".$0.".pid"],
    "child_max" => [\$child_max, 10],
    "child_min" => [\$child_min, 3],
    "child_timeout" => [\$child_timeout, 180],
    "job_queue_timeout" => [\$job_queue_timeout, undef],
    "job_queue_file_name" => [\$job_queue_file_name, '/var/lib/gosa-si/gosa-si-server_jobs.db'],
    "job_queue_loop_delay" => [\$job_queue_loop_delay, 3],
    "known_clients_file_name" => [\$known_clients_file_name, '/var/lib/gosa-si/gosa-si-server_known_clients.db' ],
    "known_server_file_name" => [\$known_server_file_name, '/var/lib/gosa-si/gosa-si-server_known_server.db'],
   },
"bus" =>
    {"bus_activ" => [\$bus_activ, "on"],
    "bus_passwd" => [\$bus_passwd, ""],
    "bus_ip" => [\$bus_ip, "0.0.0.0"],
    "bus_port" => [\$bus_port, "20080"],
    },
"server" =>
    {"server_activ" => [\$server_activ, "on"],
    "server_ip" => [\$server_ip, "0.0.0.0"],
    "server_port" => [\$server_port, "20081"],
    "SIPackages_key" => [\$SIPackages_key, "none"],
    "max_clients" => [\$max_clients, 100],
    },
"arp" =>
    {"arp_activ" => [\$arp_activ, "on"],
    "arp_fifo_path" => [\$arp_fifo_path, "/var/run/gosa-si/arp-notify"],
    },
"gosa" =>
    {"gosa_activ" => [\$gosa_activ, "on"],
    "gosa_ip" => [\$gosa_ip, "0.0.0.0"],
    "gosa_port" => [\$gosa_port, "20082"],
    "GosaPackages_key" => [\$GosaPackages_key, "none"],
    },
    );


#===  FUNCTION  ================================================================
#         NAME:  usage
#   PARAMETERS:  nothing
#      RETURNS:  nothing
#  DESCRIPTION:  print out usage text to STDERR
#===============================================================================
sub usage {
    print STDERR << "EOF" ;
usage: $0 [-hvf] [-c config]

           -h        : this (help) message
           -c <file> : config file
           -f        : foreground, process will not be forked to background
           -v        : be verbose (multiple to increase verbosity)
           -no-bus   : starts $0 without connection to bus
           -no-arp   : starts $0 without connection to arp module
 
EOF
    print "\n" ;
}


#===  FUNCTION  ================================================================
#         NAME:  read_configfile
#   PARAMETERS:  cfg_file - string -
#      RETURNS:  nothing
#  DESCRIPTION:  read cfg_file and set variables
#===============================================================================
sub read_configfile {
    my $cfg;
    if( defined( $cfg_file) && ( length($cfg_file) > 0 )) {
        if( -r $cfg_file ) {
            $cfg = Config::IniFiles->new( -file => $cfg_file );
        } else {
            print STDERR "Couldn't read config file!\n";
        }
    } else {
        $cfg = Config::IniFiles->new() ;
    }
    foreach my $section (keys %cfg_defaults) {
        foreach my $param (keys %{$cfg_defaults{ $section }}) {
            my $pinfo = $cfg_defaults{ $section }{ $param };
            ${@$pinfo[ 0 ]} = $cfg->val( $section, $param, @$pinfo[ 1 ] );
        }
    }
}


#===  FUNCTION  ================================================================
#         NAME:  logging
#   PARAMETERS:  level - string - default 'info'
#                msg - string -
#                facility - string - default 'LOG_DAEMON'
#      RETURNS:  nothing
#  DESCRIPTION:  function for logging
#===============================================================================
sub daemon_log {
    # log into log_file
    my( $msg, $level ) = @_;
    if(not defined $msg) { return }
    if(not defined $level) { $level = 1 }
    if(defined $log_file){
        open(LOG_HANDLE, ">>$log_file");
        if(not defined open( LOG_HANDLE, ">>$log_file" )) {
            print STDERR "cannot open $log_file: $!";
            return }
            chomp($msg);
            if($level <= $verbose){
                my ($seconds, $minutes, $hours, $monthday, $month,
                        $year, $weekday, $yearday, $sommertime) = localtime(time);
                $hours = $hours < 10 ? $hours = "0".$hours : $hours;
                $minutes = $minutes < 10 ? $minutes = "0".$minutes : $minutes;
                $seconds = $seconds < 10 ? $seconds = "0".$seconds : $seconds;
                my @monthnames = ("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec");
                $month = $monthnames[$month];
                $monthday = $monthday < 10 ? $monthday = "0".$monthday : $monthday;
                $year+=1900;
                my $name = $0;
                $name =~ s/\.\///;

                my $log_msg = "$month $monthday $hours:$minutes:$seconds $name $msg\n";
                print LOG_HANDLE $log_msg;
                if( $foreground ) { 
                    print STDERR $log_msg;
                }
            }
        close( LOG_HANDLE );
    }
#log into syslog
#    my ($msg, $level, $facility) = @_;
#    if(not defined $msg) {return}
#    if(not defined $level) {$level = "info"}
#    if(not defined $facility) {$facility = "LOG_DAEMON"}
#    openlog($0, "pid,cons,", $facility);
#    syslog($level, $msg);
#    closelog;
#    return;
}


sub get_time {
    my ($seconds, $minutes, $hours, $monthday, $month,
            $year, $weekday, $yearday, $sommertime) = localtime(time);
    $hours = $hours < 10 ? $hours = "0".$hours : $hours;
    $minutes = $minutes < 10 ? $minutes = "0".$minutes : $minutes;
    $seconds = $seconds < 10 ? $seconds = "0".$seconds : $seconds;
    $month+=1;
    $month = $month < 10 ? $month = "0".$month : $month;
    $monthday = $monthday < 10 ? $monthday = "0".$monthday : $monthday;
    $year+=1900;
    return "$year$month$monthday$hours$minutes$seconds";

}


#===  FUNCTION  ================================================================
#         NAME:  check_cmdline_param
#   PARAMETERS:  nothing
#      RETURNS:  nothing
#  DESCRIPTION:  validates commandline parameter
#===============================================================================
sub check_cmdline_param () {
    my $err_config;
    my $err_counter = 0;
	if(not defined($cfg_file)) {
		$cfg_file = "/etc/gosa-si/server.conf";
		if(! -r $cfg_file) {
			$err_config = "please specify a config file";
			$err_counter += 1;
		}
    }
    if( $err_counter > 0 ) {
        &usage( "", 1 );
        if( defined( $err_config)) { print STDERR "$err_config\n"}
        print STDERR "\n";
        exit( -1 );
    }
}


#===  FUNCTION  ================================================================
#         NAME:  check_pid
#   PARAMETERS:  nothing
#      RETURNS:  nothing
#  DESCRIPTION:  handels pid processing
#===============================================================================
sub check_pid {
    $pid = -1;
    # Check, if we are already running
    if( open(LOCK_FILE, "<$pid_file") ) {
        $pid = <LOCK_FILE>;
        if( defined $pid ) {
            chomp( $pid );
            if( -f "/proc/$pid/stat" ) {
                my($stat) = `cat /proc/$pid/stat` =~ m/$pid \((.+)\).*/;
                if( $0 eq $stat ) {
                    close( LOCK_FILE );
                    exit -1;
                }
            }
        }
        close( LOCK_FILE );
        unlink( $pid_file );
    }

    # create a syslog msg if it is not to possible to open PID file
    if (not sysopen(LOCK_FILE, $pid_file, O_WRONLY|O_CREAT|O_EXCL, 0644)) {
        my($msg) = "Couldn't obtain lockfile '$pid_file' ";
        if (open(LOCK_FILE, '<', $pid_file)
                && ($pid = <LOCK_FILE>))
        {
            chomp($pid);
            $msg .= "(PID $pid)\n";
        } else {
            $msg .= "(unable to read PID)\n";
        }
        if( ! ($foreground) ) {
            openlog( $0, "cons,pid", "daemon" );
            syslog( "warning", $msg );
            closelog();
        }
        else {
            print( STDERR " $msg " );
        }
        exit( -1 );
    }
}

#===  FUNCTION  ================================================================
#         NAME:  import_modules
#   PARAMETERS:  module_path - string - abs. path to the directory the modules 
#                are stored
#      RETURNS:  nothing
#  DESCRIPTION:  each file in module_path which ends with '.pm' and activation 
#                state is on is imported by "require 'file';"
#===============================================================================
sub import_modules {
    daemon_log(" ", 1);

    if (not -e $modules_path) {
        daemon_log("ERROR: cannot find directory or directory is not readable: $modules_path", 1);   
    }

    opendir (DIR, $modules_path) or die "ERROR while loading modules from directory $modules_path : $!\n";
    while (defined (my $file = readdir (DIR))) {
        if (not $file =~ /(\S*?).pm$/) {
            next;
        }
		my $mod_name = $1;

        if( $file =~ /ArpHandler.pm/ ) {
            if( $no_arp > 0 ) {
                next;
            }
        }
        
        eval { require $file; };
        if ($@) {
            daemon_log("ERROR: gosa-si-server could not load module $file", 1);
            daemon_log("$@", 5);
		} else {
			my $info = eval($mod_name.'::get_module_info()');
			# Only load module if get_module_info() returns a non-null object
			if( $info ) {
				my ($input_address, $input_key, $input, $input_active, $input_type) = @{$info};
				$known_modules->{$mod_name} = $info;
				daemon_log("module $mod_name loaded", 1);
			}
		}
    }   
    close (DIR);
}


#===  FUNCTION  ================================================================
#         NAME:  sig_int_handler
#   PARAMETERS:  signal - string - signal arose from system
#      RETURNS:  noting
#  DESCRIPTION:  handels tasks to be done befor signal becomes active
#===============================================================================
sub sig_int_handler {
    my ($signal) = @_;

    daemon_log("shutting down gosa-si-server", 1);
    exit(1);
}
$SIG{INT} = \&sig_int_handler;



sub check_key_and_xml_validity {
    my ($crypted_msg, $module_key) = @_;
#print STDERR "crypted_msg:$crypted_msg\n";
#print STDERR "modul_key:$module_key\n";

    my $msg;
    my $msg_hash;
    eval{
        $msg = &decrypt_msg($crypted_msg, $module_key);
        &main::daemon_log("decrypted_msg: \n$msg", 8);

        $msg_hash = $xml->XMLin($msg, ForceArray=>1);

        # check header
        my $header_l = $msg_hash->{'header'};
        if( 1 != @{$header_l} ) {
            die'header error';
        }
        my $header = @{$header_l}[0];
        if( 0 == length $header) {
            die 'header error';
        }

        # check source
        my $source_l = $msg_hash->{'source'};
        if( 1 != @{$source_l} ) {
            die'source error';
        }
        my $source = @{$source_l}[0];
        if( 0 == length $source) {
            die 'source error';
        }

        # check target
        my $target_l = $msg_hash->{'target'};
        if( 1 != @{$target_l} ) {
            die'target error';
        }
        my $target = @{$target_l}[0];
        if( 0 == length $target) {
            die 'target error';
        }

    };
    if($@) {
        &main::daemon_log("WARNING: do not understand the message:", 5);
        &main::daemon_log("$@", 8);
    }

    return ($msg, $msg_hash);
}


sub input_from_known_server {
    my ($input, $remote_ip) = @_ ;  
    my ($msg, $msg_hash, $module);

    my $sql_statement= "SELECT * FROM known_server";
    my $query_res = $known_server_db->select_dbentry( $sql_statement ); 
    while( my ($hit_num, $hit) = each %{ $query_res } ) {    
        my $host_name = $hit->{hostname};
        if( not $host_name =~ "^$remote_ip") {
            next;
        }
        my $host_key = $hit->{hostkey};
        daemon_log("SIPackages: host_name: $host_name", 7);
        daemon_log("SIPackages: host_key: $host_key", 7);

        # check if module can open msg envelope with module key
        my ($msg, $msg_hash) = &check_key_and_xml_validity($input, $host_key);
        if( (!$msg) || (!$msg_hash) ) {
            daemon_log("SIPackages: deciphering raise error", 7);
            daemon_log("$@", 8);
            next;
        }
        else {
            $module = "SIPackages";
            last;
        }
    }

    if( (!$msg) || (!$msg_hash) || (!$module) ) {
        daemon_log("Incoming message is not from a known server", 3);
    }
  
    return ($msg, $msg_hash, $module);
}


sub input_from_known_client {
    my ($input, $remote_ip) = @_ ;  
    my ($msg, $msg_hash, $module);

    my $sql_statement= "SELECT * FROM known_clients";
    my $query_res = $known_clients_db->select_dbentry( $sql_statement ); 
    while( my ($hit_num, $hit) = each %{ $query_res } ) {    
        my $host_name = $hit->{hostname};
        if( not $host_name =~ /^$remote_ip:\d*$/) {
            next;
		}
        my $host_key = $hit->{hostkey};
        &daemon_log("SIPackages: host_name: $host_name", 7);
        &daemon_log("SIPackages: host_key: $host_key", 7);

        # check if module can open msg envelope with module key
        ($msg, $msg_hash) = &check_key_and_xml_validity($input, $host_key);

        if( (!$msg) || (!$msg_hash) ) {
            &daemon_log("SIPackages: deciphering raise error", 7);
            &daemon_log("$@", 8);
            next;
        }
        else {
            $module = "SIPackages";
            last;
        }
    }

    if( (!$msg) || (!$msg_hash) || (!$module) ) {
        &daemon_log("Incoming message is not from a known client", 3);
    }

    return ($msg, $msg_hash, $module);
}


sub input_from_unknown_host {
    no strict "refs";
    my ($input) = @_ ;
    my ($msg, $msg_hash, $module);
    
	my %act_modules = %$known_modules;

	while( my ($mod, $info) = each(%act_modules)) {
        # check a key exists for this module
        my $module_key = ${$mod."_key"};
        if( ! $module_key ) {
            daemon_log("ERROR: no key specified in config file for $mod", 1);
            next;
        }
        daemon_log("$mod: $module_key", 5);

        # check if module can open msg envelope with module key
        ($msg, $msg_hash) = &check_key_and_xml_validity($input, $module_key);
        if( (!$msg) || (!$msg_hash) ) {
            daemon_log("$mod: deciphering failed", 5);
            next;
        }
        else {
            $module = $mod;
            last;
        }
    }

    if( (!$msg) || (!$msg_hash) || (!$module)) {
        daemon_log("Incoming message is not from a unknown host", 3);
    }

    return ($msg, $msg_hash, $module);
}

sub create_ciphering {
    my ($passwd) = @_;
    $passwd = substr(md5_hex("$passwd") x 32, 0, 32);
    my $iv = substr(md5_hex('GONICUS GmbH'),0, 16);
    my $my_cipher = Crypt::Rijndael->new($passwd , Crypt::Rijndael::MODE_CBC());
    $my_cipher->set_iv($iv);
    return $my_cipher;
}


sub encrypt_msg {
    my ($msg, $key) = @_;
    my $my_cipher = &create_ciphering($key);
    {
      use bytes;
      $msg = "\0"x(16-length($msg)%16).$msg;
    }
    $msg = $my_cipher->encrypt($msg);
    chomp($msg = &encode_base64($msg));
    # there are no newlines allowed inside msg
    $msg=~ s/\n//g;
    return $msg;
}


sub decrypt_msg {
    my ($msg, $key) = @_ ;
    $msg = &decode_base64($msg);
    my $my_cipher = &create_ciphering($key);
    $msg = $my_cipher->decrypt($msg); 
    $msg =~ s/\0*//g;
    return $msg;
}


sub get_encrypt_key {
    my ($target) = @_ ;
    my $encrypt_key;
    my $error = 0;

    # target can be in known_server
    if( !$encrypt_key ) {
        my $sql_statement= "SELECT * FROM known_server";
        my $query_res = $known_server_db->select_dbentry( $sql_statement ); 
        while( my ($hit_num, $hit) = each %{ $query_res } ) {    
            my $host_name = $hit->{hostname};
            if( $host_name ne $target ) {
                next;
            }
            my $host_key = $hit->{hostkey};
            last;
        }
    }
   

    # target can be in known_client
    if( !$encrypt_key ) {
        my $sql_statement= "SELECT * FROM known_clients";
        my $query_res = $known_clients_db->select_dbentry( $sql_statement ); 
        while( my ($hit_num, $hit) = each %{ $query_res } ) {    
            my $host_name = $hit->{hostname};
            if( $host_name ne $target ) {
                next;
            }
            $encrypt_key = $hit->{hostkey};
            last;
        }
    }

    return $encrypt_key;
}


#===  FUNCTION  ================================================================
#         NAME:  open_socket
#   PARAMETERS:  PeerAddr string something like 192.168.1.1 or 192.168.1.1:10000
#                [PeerPort] string necessary if port not appended by PeerAddr
#      RETURNS:  socket IO::Socket::INET
#  DESCRIPTION:  open a socket to PeerAddr
#===============================================================================
sub open_socket {
    my ($PeerAddr, $PeerPort) = @_ ;
    if(defined($PeerPort)){
        $PeerAddr = $PeerAddr.":".$PeerPort;
    }
    my $socket;
    $socket = new IO::Socket::INET(PeerAddr => $PeerAddr,
            Porto => "tcp",
            Type => SOCK_STREAM,
            Timeout => 5,
            );
    if(not defined $socket) {
        return;
    }
    &daemon_log("open_socket: $PeerAddr", 7);
    return $socket;
}


sub send_msg_to_target {
    my ($msg, $address, $encrypt_key, $msg_header) = @_ ;
    my $error = 0;

    if( $msg_header ) {
        $msg_header = "'$msg_header'-";
    }
    else {
        $msg_header = "";
    }

    # encrypt xml msg
    my $crypted_msg = &encrypt_msg($msg, $encrypt_key);

    # opensocket
    my $socket = &open_socket($address);
    if( !$socket ) {
        daemon_log("cannot send ".$msg_header."msg to $address , host not reachable", 1);
        $error++;
    }
    
    if( $error == 0 ) {
        # send xml msg
        print $socket $crypted_msg."\n";

        daemon_log("send ".$msg_header."msg to $address", 1);
        daemon_log("message:\n$msg", 8);

    }

    # close socket in any case
    if( $socket ) {
        close $socket;
    }

    return;
}


sub _start {
    my ($kernel) = $_[KERNEL];
    &trigger_db_loop($kernel);
}


sub client_input {
    no strict "refs";
    my ($heap,$input,$wheel) = @_[HEAP, ARG0, ARG1];
    my ($msg, $msg_hash, $module);
    my $error = 0;
    my $answer_l;
    my ($answer_header, @answer_target_l, $answer_source);
    my $client_answer;

    daemon_log("Incoming msg:\n$input\n", 8);

    # msg is from a new client or gosa
    ($msg, $msg_hash, $module) = &input_from_unknown_host($input);

    # msg is from a gosa-si-server or gosa-si-bus
    if(( !$msg ) || ( !$msg_hash ) || ( !$module )){
        ($msg, $msg_hash, $module) = &input_from_known_server($input, $heap->{'remote_ip'});
    }

    # msg is from a gosa-si-client
    if(( !$msg ) || ( !$msg_hash ) || ( !$module )){
        ($msg, $msg_hash, $module) = &input_from_known_client($input, $heap->{'remote_ip'});
    }

    # an error occurred
    if(( !$msg ) || ( !$msg_hash ) || ( !$module )){
        $error++;
    }

    ######################
    # process incoming msg
    if( $error == 0) {
        daemon_log("Processing module ".$module, 3);
        $answer_l = &{ $module."::process_incoming_msg" }($msg, $msg_hash, $heap->{'remote_ip'});

        if ( 0 > @{$answer_l} ) {
            my $answer_str = join("\n", @{$answer_l});
            daemon_log("$module: Got answer from module: \n".$answer_str,8);
        }
    }
    if( !$answer_l ) { $error++ };

    ########
    # answer
    if( $error == 0 ) {

        # for each answer in answer list
        foreach my $answer ( @{$answer_l} ) {

            # check answer if gosa-si envelope conform
            if( $error == 0 ) {
                my $answer_hash = $xml->XMLin($answer, ForceArray=>1);
                $answer_header = @{$answer_hash->{'header'}}[0];
                @answer_target_l = @{$answer_hash->{'target'}};
                $answer_source = @{$answer_hash->{'source'}}[0];
                if( !$answer_header ) {
                    daemon_log('ERROR: module answer is not gosa-si envelope conform: no header', 1);
                    $error++;
                }
                if( 0 == length @answer_target_l ) {
                    daemon_log('ERROR: module answer is not gosa-si envelope conform: no targets', 1);
                    $error++;
                }
                if( !$answer_source ) {
                    daemon_log('ERROR: module answer is not gosa-si envelope conform: no source', 1);
                    $error++;
                }

                if( $error != 0 ) {
                    next;
                }

                # deliver msg to all targets 
                foreach my $answer_target ( @answer_target_l ) {
                    if( $answer_target eq "*" ) {
                        # answer is for all clients
                        my $sql_statement= "SELECT * FROM known_clients";
                        my $query_res = $known_clients_db->select_dbentry( $sql_statement ); 
                        while( my ($hit_num, $hit) = each %{ $query_res } ) {    
                            my $host_name = $hit->{hostname};
                            my $host_key = $hit->{hostkey};
                            &send_msg_to_target($answer, $host_name, $host_key, $answer_header);
                        }
                    }
                    elsif( $answer_target eq "GOSA" ) {
                        # answer is for GOSA and has to returned to connected client
                        my $gosa_answer = &encrypt_msg($answer, $GosaPackages_key);
                        $client_answer = $gosa_answer;
                    }
                    elsif( $answer_target eq "KNOWN_SERVER" ) {
                        # answer is for all server in known_server
                        my $sql_statement= "SELECT * FROM known_server";
                        my $query_res = $known_server_db->select_dbentry( $sql_statement ); 
                        while( my ($hit_num, $hit) = each %{ $query_res } ) {    
                            my $host_name = $hit->{hostname};
                            my $host_key = $hit->{hostkey};
                            $answer =~ s/KNOWN_SERVER/$host_name/g;
                            &send_msg_to_target($answer, $host_name, $host_key, $answer_header);
                        }
                    }
                    else {
                        # answer is for one specific host
                        # get encrypt_key
                        my $encrypt_key = &get_encrypt_key($answer_target);
                        if( !$encrypt_key ) {
                            daemon_log("ERROR: no encrypt key found for answer target '$answer_target'", 1);
                            next;
                        }
                        # send_msg
                        &send_msg_to_target($answer, $answer_target, $encrypt_key, $answer_header);
                    }
                }
            }
        }
    }

    if( $client_answer ) {
        $heap->{client}->put($client_answer);
    }

    return;
}



sub trigger_db_loop {
#	my ($kernel) = $_[KERNEL];
	my ($kernel) = @_ ;
	$kernel->delay_set('watch_for_new_jobs',3);
}


sub watch_for_new_jobs {
	my ($kernel,$heap) = @_[KERNEL, HEAP];

	# check gosa job queue for jobs with executable timestamp
    my $timestamp = &get_time();

    my $sql_statement = "SELECT * FROM ".$job_queue_table_name.
        " WHERE status='waiting' AND timestamp<'$timestamp'";

	my $res = $job_db->select_dbentry( $sql_statement );

	while( my ($id, $hit) = each %{$res} ) {         

		my $jobdb_id = $hit->{id};
		my $macaddress = $hit->{macaddress};
		my $job_msg_hash = &transform_msg2hash($hit->{xmlmessage});
		my $out_msg_hash = $job_msg_hash;
        my $sql_statement = "SELECT * FROM known_clients WHERE macaddress='$macaddress'";
		my $res_hash = $known_clients_db->select_dbentry( $sql_statement );
		# expect macaddress is unique!!!!!!
		my $target = $res_hash->{1}->{hostname};

		if (not defined $target) {
			&daemon_log("ERROR: no host found for mac address: $job_msg_hash->{mac}[0]", 1);
			&daemon_log("xml message: $hit->{xmlmessage}", 5);
            my $sql_statement = "UPDATE $job_queue_table_name ".
                "SET status='error', result='no host found for mac address' ".
                "WHERE id='$jobdb_id'";
			my $res = $job_db->update_dbentry($sql_statement);
			next;
		}

		# add target
		&add_content2xml_hash($out_msg_hash, "target", $target);

		# add new header
		my $out_header = $job_msg_hash->{header}[0];
		$out_header =~ s/job_/gosa_/;
		delete $out_msg_hash->{header};
		&add_content2xml_hash($out_msg_hash, "header", $out_header);

		# add sqlite_id 
		&add_content2xml_hash($out_msg_hash, "jobdb_id", $jobdb_id); 

		my $out_msg = &create_xml_string($out_msg_hash);

		# encrypt msg as a GosaPackage module
		my $cipher = &create_ciphering($GosaPackages_key);
		my $crypted_out_msg = &encrypt_msg($out_msg, $cipher);

		my $error = &send_msg_hash2address($out_msg_hash, "$gosa_ip:$gosa_port", $GosaPackages_key);

		if ($error == 0) {
			my $sql_statement = "UPDATE $job_queue_table_name ".
                "SET status='processing', targettag='$target' ".
                "WHERE id='$jobdb_id'";
			my $res = $job_db->update_dbentry($sql_statement);
		} else {
            my $sql_statement = "UPDATE $job_queue_table_name ".
                "SET status='error' ".
                "WHERE id='$jobdb_id'";
			my $res = $job_db->update_dbentry($sql_statement);
		}
	}

	$kernel->delay_set('watch_for_new_jobs',3);
}


#==== MAIN = main ==============================================================
#  parse commandline options
Getopt::Long::Configure( "bundling" );
GetOptions("h|help" => \&usage,
        "c|config=s" => \$cfg_file,
        "f|foreground" => \$foreground,
        "v|verbose+" => \$verbose,
        "no-bus+" => \$no_bus,
        "no-arp+" => \$no_arp,
           );

#  read and set config parameters
&check_cmdline_param ;
&read_configfile;
&check_pid;

$SIG{CHLD} = 'IGNORE';

# forward error messages to logfile
if( ! $foreground ) {
    open(STDERR, '>>', $log_file);
    open(STDOUT, '>>', $log_file);
}

# Just fork, if we are not in foreground mode
if( ! $foreground ) { 
    chdir '/'                 or die "Can't chdir to /: $!";
    $pid = fork;
    setsid                    or die "Can't start a new session: $!";
    umask 0;
} else { 
    $pid = $$; 
}

# Do something useful - put our PID into the pid_file
if( 0 != $pid ) {
    open( LOCK_FILE, ">$pid_file" );
    print LOCK_FILE "$pid\n";
    close( LOCK_FILE );
    if( !$foreground ) { 
        exit( 0 ) 
    };
}

daemon_log(" ", 1);
daemon_log("$0 started!", 1);

# delete old DBsqlite lock files
system('rm -f /tmp/gosa_si_lock*gosa-si-server*');

# connect to gosa-si job queue
my @job_col_names = ("id", "timestamp", "status", "result", "headertag", "targettag", "xmlmessage", "macaddress");
$job_db = GOSA::DBsqlite->new($job_queue_file_name);
$job_db->create_table('jobs', \@job_col_names);

# connect to known_clients_db
my @clients_col_names = ('hostname', 'status', 'hostkey', 'timestamp', 'macaddress', 'events');
$known_clients_db = GOSA::DBsqlite->new($known_clients_file_name);
$known_clients_db->create_table('known_clients', \@clients_col_names);

# connect to known_server_db
my @server_col_names = ('hostname', 'status', 'hostkey', 'timestamp');
$known_server_db = GOSA::DBsqlite->new($known_server_file_name);
$known_server_db->create_table('known_server', \@server_col_names);

# import all modules
&import_modules;

# check wether all modules are gosa-si valid passwd check

# create xml object used for en/decrypting
$xml = new XML::Simple();


# create socket for incoming xml messages
POE::Component::Server::TCP->new(
	Port => $server_port,
	ClientInput => \&client_input,
);
daemon_log("start socket for incoming xml messages at port '$server_port' ", 1);

# create session for repeatedly checking the job queue for jobs
POE::Session->create(
	inline_states => {
		_start => \&_start,
		watch_for_new_jobs => \&watch_for_new_jobs,
	}
);

POE::Kernel->run();
exit;

