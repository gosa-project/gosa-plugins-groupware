#!/usr/bin/perl
#===============================================================================
#
#         FILE:  gosa-server
#
#        USAGE:  ./gosa-server
#
#  DESCRIPTION:
#
#      OPTIONS:  ---
# REQUIREMENTS:  ---
#         BUGS:  ---
#        NOTES: 
#       AUTHOR:   (Andreas Rettenberger), <rettenberger@gonicus.de>
#      COMPANY:
#      VERSION:  1.0
#      CREATED:  12.09.2007 08:54:41 CEST
#     REVISION:  ---
#===============================================================================

use strict;
use warnings;
use Getopt::Long;
use Config::IniFiles;
use POSIX;
use Time::HiRes qw( gettimeofday );

use IO::Socket::INET;
use Crypt::Rijndael;
use XML::Simple;
use Data::Dumper;
use Sys::Syslog qw( :DEFAULT setlogsock);
use IPC::Shareable qw( :lock);
IPC::Shareable->clean_up_all;

my ($cfg_file, %cfg_defaults, $foreground, $verbose);
my ($bus_activ, $bus_passwd, $bus_ip, $bus_port, $bus_address, $bus);
my ($pid_file, $procid, $pid, $log_file, $my_own_address);
my (%free_child, %busy_child, $child_max, $child_min, %child_alive_time, $child_timeout);
my ($xml, $bus_cipher, $known_hosts, $shmkh);

$foreground = 0 ;
$known_hosts = {};
$shmkh = tie($known_hosts, 'IPC::Shareable', undef, {create => 1, 
                                                            exclusive => 1, 
                                                            mode => 0666, 
                                                            destroy => 1,
                                                            });


%cfg_defaults =
("general" =>
    {"log_file" => [\$log_file, "/var/run/".$0.".log"],
    "pid_file" => [\$pid_file, "/var/run/".$0.".pid"],

    },
"bus" =>
    {"bus_activ" => [\$bus_activ, "on"],
    "bus_passwd" => [\$bus_passwd, "tester78901234567890123456789012"],
    "bus_ip" => [\$bus_ip, "10.89.1.155"],
    "bus_port" => [\$bus_port, "10001"],
    "child_max" => [\$child_max, 10],
    "child_min" => [\$child_min, 3],
    "child_timeout" => [\$child_timeout, 180],
    }
    );

#===  FUNCTION  ================================================================
#         NAME:  read_configfile
#   PARAMETERS:  cfg_file - string - 
#      RETURNS:  
#  DESCRIPTION: 
#===============================================================================
sub read_configfile {
    my $cfg;
    if( defined( $cfg_file) && ( length($cfg_file) > 0 )) {
        if( -r $cfg_file ) {
            $cfg = Config::IniFiles->new( -file => $cfg_file );
        } else {
            print STDERR "Couldn't read config file!";
        }
    } else {
        $cfg = Config::IniFiles->new() ;
    }
    foreach my $section (keys %cfg_defaults) {
        foreach my $param (keys %{$cfg_defaults{ $section }}) {
            my $pinfo = $cfg_defaults{ $section }{ $param };
            ${@$pinfo[ 0 ]} = $cfg->val( $section, $param, @$pinfo[ 1 ] );
        }
    }
}

#===  FUNCTION  ================================================================
#         NAME:  logging
#   PARAMETERS:  level - string - default 'info' 
#                msg - string - 
#                facility - string - default 'LOG_DAEMON' 
#      RETURNS:  
#  DESCRIPTION: 
#===============================================================================
sub daemon_log {
    my( $msg, $level ) = @_;
    if(not defined $msg) { return }
    if(not defined $level) { $level = 1 }
    if(defined $log_file){
        open(LOG_HANDLE, ">>$log_file");
        if(not defined open( LOG_HANDLE, ">>$log_file" )) { 
            print STDERR "cannot open $log_file: $!";
            return }
        chomp($msg);
        if($level <= $verbose){
            print LOG_HANDLE $msg."\n";
            if(defined $foreground) { print $msg."\n" }
        }
    }
    close( LOG_HANDLE );
#    my ($msg, $level, $facility) = @_;
#    if(not defined $msg) {return}
#    if(not defined $level) {$level = "info"}
#    if(not defined $facility) {$facility = "LOG_DAEMON"}
#    openlog($0, "pid,cons,", $facility);
#    syslog($level, $msg);
#    closelog;
#    return;
}

#===  FUNCTION  ================================================================
#         NAME: check_cmdline_param
#   PARAMETERS: 
#      RETURNS:  
#  DESCRIPTION: 
#===============================================================================
sub check_cmdline_param () {
    my $err_config;
    my $err_counter = 0;
    if( not defined( $cfg_file)) {
        $err_config = "please specify a config file";
        $err_counter += 1;
    }
    if( $err_counter > 0 ) {
        &usage( "", 1 );
        if( defined( $err_config)) { print STDERR "$err_config\n"}
        print STDERR "\n";
        exit( -1 );
    }
}

#===  FUNCTION  ================================================================
#         NAME: check_pid
#   PARAMETERS:
#      RETURNS:
#  DESCRIPTION:
#===============================================================================
sub check_pid {
    $pid = -1;
    # Check, if we are already running
    if( open(LOCK_FILE, "<$pid_file") ) {
        $pid = <LOCK_FILE>;
        if( defined $pid ) {
            chomp( $pid );
            if( -f "/proc/$pid/stat" ) {
                my($stat) = `cat /proc/$pid/stat` =~ m/$pid \((.+)\).*/;
                if( $0 eq $stat ) {
                    close( LOCK_FILE );
                    exit -1;
                }
            }
        }
        close( LOCK_FILE );
        unlink( $pid_file );
    }

    # create a syslog msg if it is not to possible to open PID file
    if (not sysopen(LOCK_FILE, $pid_file, O_WRONLY|O_CREAT|O_EXCL, 0644)) {
        my($msg) = "Couldn't obtain lockfile '$pid_file' ";
        if (open(LOCK_FILE, '<', $pid_file)
                && ($pid = <LOCK_FILE>))
        {
            chomp($pid);
            $msg .= "(PID $pid)\n";
        } else {
            $msg .= "(unable to read PID)\n";
        }
        if( ! ($foreground) ) {
            openlog( $0, "cons,pid", "daemon" );
            syslog( "warning", $msg );
            closelog();
        }
        else {
            print( STDERR " $msg " );
        }
        exit( -1 );
    }
}


#===  FUNCTION  ================================================================
#         NAME:  usage
#   PARAMETERS: 
#      RETURNS:  
#  DESCRIPTION: 
#===============================================================================
sub usage {
        my( $text, $help ) = @_;
        $text = undef if( "h" eq $text );
        (defined $text) && print STDERR "\n$text\n";
        if( (defined $help && $help) || (!defined $help && !defined $text) ) {
                print STDERR << "EOF" ;
usage: $0 [-hvf] [-c config]

    -h        : this (help) message
    -c <file> : config file
    -f        : foreground, process will not be forked to background
    -v        : be verbose (multiple to increase verbosity)
EOF
        }
        print "\n" ;
}


#===  FUNCTION  ================================================================
#         NAME:  sig_int_handler
#   PARAMETERS:
#      RETURNS:
#  DESCRIPTION:
#===============================================================================
sub sig_int_handler {
    my ($signal) = @_;
    if($bus){
        close($bus);
        print "$bus closed\n";
    }
    print "$signal\n";
    IPC::Shareable->clean_up;
    exit(1);
}
$SIG{INT} = \&sig_int_handler;


#===  FUNCTION  ================================================================
#         NAME:  activating_child
#   PARAMETERS:
#      RETURNS:
#  DESCRIPTION:
#===============================================================================
sub activating_child {
    my ($msg, $host) = @_;
    my $child = &get_processing_child();
    my $pipe_wr = $$child{'pipe_wr'};

    daemon_log("activating: childpid: $$child{'pid'}", 5);

    print $pipe_wr $msg.".".$host."\n";
    return;

}


#===  FUNCTION  ================================================================
#         NAME:  get_processing_child
#   PARAMETERS:
#      RETURNS:
#  DESCRIPTION:
#===============================================================================
sub get_processing_child {
    my $child;
    # schaue durch alle %busy_child{pipe_wr} ob irgendwo 'done' drinsteht, wenn ja, dann setze das kind von busy auf free um
    while(my ($key, $val) = each(%busy_child)) {
        # test ob prozess noch existiert
        my $exitus_pid = waitpid($key, WNOHANG);
        if($exitus_pid != 0) {
            delete $busy_child{$key};
            daemon_log( "prozess:$key wurde aus busy_child entfernt\n", 5);
            next;
        }

        # test ob prozess noch arbeitet
        my $fh = $$val{'pipe_rd'};
        $fh->blocking(0); 
        my $child_answer;
        if(not $child_answer = <$fh>) { next }
        chomp($child_answer);
        if($child_answer eq "done") {
            delete $busy_child{$key};
            $free_child{$key} = $val;
        }
    }

    while(my ($key, $val) = each(%free_child)) {
        my $exitus_pid = waitpid($key, WNOHANG);
        if($exitus_pid != 0) {
            delete $free_child{$key};
            daemon_log( "prozess:$key wurde aus free_child entfernt\n", 5);
        }
        daemon_log("free child:$key\n", 5);
    }
    # teste @free_child und @busy_child
    my $free_len = scalar(keys(%free_child));
    my $busy_len = scalar(keys(%busy_child));
    daemon_log("free children $free_len, busy children $busy_len\n",5);
    
    # gibt es bereits ein freies kind, dann lass es arbeiten
    if($free_len > 0){
        my @keys = keys(%free_child);
        $child = $free_child{$keys[0]};
        if(defined $child) {
            $busy_child{$$child{'pid'}} = $child ; 
            delete $free_child{$$child{'pid'}};          
        }
        return $child;
    }
    
    # no free child, try to fork another one 
    if($free_len + $busy_len < $child_max) {
                
        daemon_log("not enough children, create a new one\n",5);

        # New pipes for communication
        my( $PARENT_wr, $PARENT_rd );
        my( $CHILD_wr, $CHILD_rd );
        pipe( $CHILD_rd,  $PARENT_wr );
        pipe( $PARENT_rd, $CHILD_wr  );
        $PARENT_wr->autoflush(1);
        $CHILD_wr->autoflush(1);

        ############
        # fork child
        ############
        my $child_pid = fork();
        
        #CHILD
        if($child_pid == 0) {
            # Close unused pipes
            close( $CHILD_rd );
            close( $CHILD_wr );
            while( 1 ) {
                my $rbits = "";
                vec( $rbits, fileno $PARENT_rd , 1 ) = 1;
                my $nf = select($rbits, undef, undef, $child_timeout);
                if($nf < 0 ) {
                    # wenn $nf < 1, error handling
                    die "select(): $!\n";
                } elsif (! $nf) {
                    # ist dieses kind nicht eines der letzenen $child_min, dann springe aus while schleife raus
                    $free_len = scalar(keys(%free_child));
                    $busy_len = scalar(keys(%busy_child));
                    if($free_len + $busy_len >= $child_min) {
                        last;
                    } else {
                        redo;
                    }
                } 

                # ansonsten
                if ( vec $rbits, fileno $PARENT_rd, 1 ) {
                    # hole alles was in der pipe ist
                    my $msg = "";
                    $PARENT_rd->blocking(0);
                    while(1) {
                        my $read = <$PARENT_rd>;
                        if(not defined $read) { last}
                        $msg .= $read;
                    }                   
                    &process_incoming_msg($msg);
                    daemon_log("processing of msg finished", 5);

                    # wichtig!!! erst mit dem done wird das child nach free_child geschoben
                    print $PARENT_wr "done";
                    redo;
                }
            }
            # kinder die die while-schleife verlassen haben sterben
            exit(0);

        #PARENT
        } else {
            # Close unused pipes
            close( $PARENT_rd );
            close( $PARENT_wr );
            # add child to child alive hash
            my %child_hash = (
                    'pid' => $child_pid,
                    'pipe_wr' => $CHILD_wr,
                    'pipe_rd' => $CHILD_rd,
                    );

            $child = \%child_hash;
            $busy_child{$$child{'pid'}} = $child;
            return $child;
        }
    }
}


#===  FUNCTION  ================================================================
#         NAME:  process_incoming_msg
#   PARAMETERS:  
#      RETURNS:
#  DESCRIPTION:
#===============================================================================
sub process_incoming_msg {
    my ($crypted_msg) = @_;
    if(not defined $crypted_msg) {
        daemon_log("function 'process_incoming_msg': got no msg", 7);
        return;
    }
    $crypted_msg =~ /^([\s\S]*?)\.(\d{1,3}?)\.(\d{1,3}?)\.(\d{1,3}?)\.(\d{1,3}?)$/;
    $crypted_msg = $1;
    my $host = sprintf("%s.%s.%s.%s", $2, $3, $4, $5);

    daemon_log("msg from host:\n\t$host", 1);
    daemon_log("crypted_msg:\n\t$crypted_msg", 7);

    my @valid_keys;
    my @host_keys = keys %$known_hosts;
    my $l = @host_keys;
    daemon_log("number of host_keys: $l\n", 7);

    foreach my $host_key (@host_keys) {    
        if($host_key =~ "^$host") {
            push(@valid_keys, $host_key);
        }
    }
    
    my ($msg, $msg_hash);
    my $msg_flag = 0;    

    # ermittle alle in frage kommenden known_hosts einträge
    foreach my $host_key (@valid_keys) {
        eval{
            daemon_log( "key: $host_key\n", 7);
            my $key_passwd = $known_hosts->{$host_key}->{passwd};
            daemon_log("key_passwd: $key_passwd\n", 7);
            my $key_cipher = &create_ciphering($key_passwd);
            $msg = &decrypt_msg($crypted_msg, $key_cipher);
            $msg_hash = $xml->XMLin($msg, ForceArray=>1);
        };
        if($@) {
            daemon_log("key raise error", 7);
            $msg_flag += 1;
        } else {
            last;
        }
    } 
    
    if($msg_flag >= $l)  {
        daemon_log("\nERROR: do not understand the message:\n\t$msg" , 1);
        return;
    }

    my $header = &get_content_from_xml_hash($msg_hash, "header");
    my $target = &get_content_from_xml_hash($msg_hash, "target");

    daemon_log("header from msg:\n\t$header", 1);
    daemon_log("msg to process:\n\t$msg", 7);

    if($target eq "$bus_ip:$bus_port") {
        if($header eq 'here_i_am'){ &here_i_am($msg_hash)}
        elsif($header eq 'confirm_new_passwd'){ &confirm_new_passwd($msg_hash)}
        elsif($header eq 'got_ping') { &got_ping($msg_hash)} 
        elsif($header eq 'ping') { &ping($msg_hash)}
    } else {
        print "bus leitet $header an $target weiter\n";
        # bus ist nicht der ziel rechner
        # leite msg an ziel rechner weiter

    }

    &print_known_hosts_hash();
    return;
}


#===  FUNCTION  ================================================================
#         NAME:  get_content_of_known_hosts
#   PARAMETERS:
#      RETURNS:
#  DESCRIPTION:
#===============================================================================
sub get_content_of_known_hosts {
    my ($host, $content) = @_;
    return;
}


#===  FUNCTION  ================================================================
#         NAME:  encrypt_msg
#   PARAMETERS:
#      RETURNS:
#  DESCRIPTION:
#===============================================================================
sub encrypt_msg {
    my ($msg, $my_cipher) = @_;
    $msg =~ s/[\s]+//g;
    my $msg_length = length($msg);
    my $multiplier = int($msg_length / 16) + 1;
    my $extension = 16*$multiplier - $msg_length;
    $msg = "a"x$extension.$msg;
    my $crypted_msg = $my_cipher->encrypt($msg);
    #my $crypted_msg = $msg;
    return $crypted_msg;
}


#===  FUNCTION  ================================================================
#         NAME:  decrypt_msg
#   PARAMETERS:
#      RETURNS:
#  DESCRIPTION:
#===============================================================================
sub decrypt_msg {
    my ($crypted_msg, $my_cipher) =@_;
    my $len = length $crypted_msg;
    my $msg = $my_cipher->decrypt($crypted_msg);
    #my $msg = $crypted_msg;
    $msg =~ s/^a*//gi;
    return $msg;
}


#===  FUNCTION  ================================================================
#         NAME:  create_xml_hash
#   PARAMETERS:  
#      RETURNS:
#  DESCRIPTION:
#===============================================================================
sub create_xml_hash {
    my ($header, $source, $target) = @_;
    my $hash = {
            header => [$header],
            source => [$source],
            target => [$target],
            $header => [],
    };
    daemon_log("create_xml_hash:", 7),
    chomp(my $tmp = Dumper $hash);
    daemon_log("\t$tmp\n", 7);
    return $hash
}


sub create_xml_string {
    my ($xml_hash) = @_ ;
    my $xml_string = $xml->XMLout($xml_hash, RootName => 'xml');
    $xml_string =~ s/[\s]+//g;
    return $xml_string;
}


sub add_content2xml_hash {
    my ($xml_ref, $element, $content) = @_;
    if(not exists $$xml_ref{$element} ) {
        $$xml_ref{$element} = [];
    }
    my $tmp = $$xml_ref{$element};
    push(@$tmp, $content);
    return;
}


#===  FUNCTION  ================================================================
#         NAME:  get_content_from_xml_hash
#   PARAMETERS:
#      RETURNS:
#  DESCRIPTION:
#===============================================================================
sub get_content_from_xml_hash {
    my ($xml_ref, $element) = @_;
    my $result = $xml_ref->{$element};
    if( $element eq "header" || $element eq "target" || $element eq "source") {
        $result = @$result[0];
    }
    return $result;
}


#===  FUNCTION  ================================================================
#         NAME:  open_socket
#   PARAMETERS:  PeerAddr string something like 192.168.1.1 or 192.168.1.1:10000
#                [PeerPort] string necessary if port not appended by PeerAddr
#      RETURNS:  socket IO::Socket::INET
#  DESCRIPTION:
#===============================================================================
sub open_socket {
    my ($PeerAddr, $PeerPort) = @_ ;
    if(defined($PeerPort)){
        $PeerAddr = $PeerAddr.":".$PeerPort;
    }
    my $socket;
    $socket = new IO::Socket::INET(PeerAddr => $PeerAddr ,
            Porto => "tcp" ,
            Type => SOCK_STREAM,
            Reuse => 1,
            Timeout => 5,
            );
    if(not defined $socket) {
        #daemon_log("cannot connect to socket at $PeerAddr, $@\n");
        return;
    }
    return $socket;
}

#===  FUNCTION  ================================================================
#         NAME:  read_from_socket
#   PARAMETERS:  socket fh - 
#      RETURNS:  result string - readed characters from socket
#  DESCRIPTION:  reads data from socket in 16 byte steps
#===============================================================================
sub read_from_socket {
    my ($socket) = @_;
    my $result = "";
    my $len = 16;
    while($len == 16){
        my $char;
        $len = sysread($socket, $char, 16);
        if($len != 16) { last }
        #print "$char\n";
        #print "              $len\n";
        if($len != 16) { last }
        $result .= $char;
    }
    return $result;
}


#===  FUNCTION  ================================================================
#         NAME:  send_msg_hash2address
#   PARAMETERS:  msg string - xml message
#                PeerAddr string - socket address to send msg
#                PeerPort string - socket port, if not included in socket address
#      RETURNS:  nothing
#  DESCRIPTION:  ????
#===============================================================================
sub send_msg_hash2address {
    my ($msg_hash, $address) = @_ ;

    # fetch header for logging
    my $header = &get_content_from_xml_hash($msg_hash, "header");
    # generiere xml string
    my $msg_xml = &create_xml_string($msg_hash);
    # hole das entsprechende passwd aus dem hash
    my $passwd = $known_hosts->{$address}->{passwd};
    # erzeuge ein ciphering object
    my $act_cipher = &create_ciphering($passwd);
    # encrypt xml msg
    my $crypted_msg = &encrypt_msg($msg_xml, $act_cipher);
    # öffne socket
    my $socket = &open_socket($address);
    if(not defined $socket){
        print "cannot send '$header'-msg to $address , server not reachable\n";
        return;
    }
    # versende xml msg
    print $socket $crypted_msg."\n";
    # schließe socket
    close $socket;
    daemon_log("send '$header'-msg to $address", 5);
    daemon_log("crypted_msg:\n\t$crypted_msg", 7);
    return
}


#===  FUNCTION  ================================================================
#         NAME:  
#   PARAMETERS:
#      RETURNS:  
#  DESCRIPTION:
#===============================================================================
sub send_msg_hash2all {
    my ($msg_hash) = @_;
    # fetch header for logging
    my $header = &get_content_from_xml_hash($msg_hash, "header");
    # generiere xml string
    my $msg_xml = &create_xml_string($msg_hash);
    # hole die liste von target adressen
    my @targets = keys(%$known_hosts);
    # itteriere durch liste und schicke an jeden msg_xml
    foreach my $target (@targets) {
        if($target eq $bus_address) {next};   # schicke die nachricht nicht an den bus
        # hole das entsprechende passwd aus dem hash
        my $passwd = $known_hosts->{$target}->{passwd};
        # erzeuge ein ciphering object
        my $act_cipher = &create_ciphering($passwd);
        # encrypt xml msg
        my $crypted_msg = &encrypt_msg($msg_xml, $act_cipher);
        # öffne socket
        my $socket = &open_socket($target);
        if(not defined $socket){
            # hole status für den server aus hash
            my $status = $known_hosts->{$target}->{status};
            if(not $status eq "down") {
                daemon_log("cannot open socket to $target , server not reachable", 1);
                # update status
                &update_known_hosts_entry($target, "down");
            }
            next;
        }
        # versende xml msg
        print $socket $crypted_msg."\n";
        # schließe socket
        close $socket;
        daemon_log("send '$header'-msg to $target", 5);
        daemon_log("crypted_msg:\n\t$crypted_msg", 7);
    }
    return;
}


#===  FUNCTION  ================================================================
#         NAME:  create_ciphering_object
#   PARAMETERS:
#      RETURNS:  cipher object
#  DESCRIPTION:
#===============================================================================
sub create_ciphering {
    my ($passwd) = @_;
    my $passwd_length = length $passwd;
    my $multiplier = int($passwd_length / 32) + 1;
    my $extension = 32*$multiplier - $passwd_length;
    $passwd = "a"x$extension.$passwd;

    my $my_cipher = Crypt::Rijndael->new($passwd , Crypt::Rijndael::MODE_CBC );
    return $my_cipher;
}


#===  FUNCTION  ================================================================
#         NAME:  create_passwd
#   PARAMETERS:
#      RETURNS:  cipher object
#  DESCRIPTION:
#===============================================================================
sub create_passwd {
    my $new_passwd = "";
    for(my $i=0; $i<31; $i++) {
        $new_passwd .= ("a".."z","A".."Z",0..9)[int(rand(62))]
    }

    return $new_passwd;
}


#===  FUNCTION  ================================================================
#         NAME:  here_i_am
#   PARAMETERS:
#      RETURNS: 
#  DESCRIPTION:
#===============================================================================
sub here_i_am {
    my ($msg_hash) = @_;
    my $source = &get_content_from_xml_hash($msg_hash, "source");
    #my $timestamp = time;

    my $new_passwd = &create_passwd();

    # create known_hosts entry
    &create_known_hosts_entry($source);
    &update_known_hosts_entry($source, "registered", $bus_passwd);

    # create outgoing msg
    my $out_hash = &create_xml_hash("new_passwd", "$bus_ip:$bus_port", $source);
    &add_content2xml_hash($out_hash, "new_passwd", $new_passwd);
    &send_msg_hash2address($out_hash, $source);

    # change passwd, reason
    # &send_msg_hash2address takes $known_hosts->{"$source"}->{passwd} to cipher msg
    &update_known_hosts_entry($source, "new_passwd", $new_passwd);

    return;
}


#===  FUNCTION  ================================================================
#         NAME:  confirm_new_passwd
#   PARAMETERS:
#      RETURNS: 
#  DESCRIPTION: 
#===============================================================================
sub confirm_new_passwd {
    my ($msg_hash) = @_;
    my $source = &get_content_from_xml_hash($msg_hash, "source");
    &update_known_hosts_entry($source, "confirmed_new_passwd");
    return;
}


#===  FUNCTION  ================================================================
#         NAME:  ping
#   PARAMETERS:
#      RETURNS: 
#  DESCRIPTION: 
#===============================================================================
sub ping {
    my ($msg_hash) = @_;
    my $source = &get_content_from_xml_hash($msg_hash, "source");   
    my $out_hash = &create_xml_hash("got_ping", $bus_address, $source);
    &send_msg_hash2address($out_hash, $source);
    return;
}


#===  FUNCTION  ================================================================
#         NAME:  make ping
#   PARAMETERS:
#      RETURNS: 
#  DESCRIPTION: 
#===============================================================================
sub make_ping {
    my ($address) = @_;
    daemon_log("ping:$address\n", 1);
    my $out_hash = &create_xml_hash("ping", "$bus_ip:$bus_port", $address);
    &send_msg_hash2address($out_hash, $address);
    return;
}


#===  FUNCTION  ================================================================
#         NAME:  got_ping
#   PARAMETERS:
#      RETURNS: 
#  DESCRIPTION: 
#===============================================================================
sub got_ping {
    my ($msg_hash) = @_;
    my $source = &get_content_from_xml_hash($msg_hash, "source");
    &update_known_hosts_entry($source, "got_ping");
    return;
}

#===  FUNCTION  ================================================================
#         NAME:  print_known_hosts_hash
#   PARAMETERS:
#      RETURNS: 
#  DESCRIPTION: 
#===============================================================================
sub print_known_hosts_hash {
    my ($tmp) = @_;
    print "####################################\n";
    print "# status of $known_hosts\n";
    my $hosts;
    my $host_hash;
    $shmkh->shlock(LOCK_EX);
    my @hosts = keys %$known_hosts;
    foreach my $host (@hosts) {
        #my @elements = keys %$known_hosts->{$host};
        my $status = $known_hosts->{$host}->{status} ;
        my $passwd = $known_hosts->{$host}->{passwd};
        my $timestamp = $known_hosts->{$host}->{timestamp};
        print "$host\n";
        print "\t$status\n";
        print "\t$passwd\n";
        print "\t$timestamp\n";
    }
    $shmkh->shunlock(LOCK_EX);
    print "####################################\n\n";
    return;
}

sub create_known_hosts_entry {
    my ($hostname) = @_;
    $shmkh->shlock(LOCK_EX);
    $known_hosts->{$hostname} = {};
    $known_hosts->{$hostname}->{status} = "none";
    $known_hosts->{$hostname}->{passwd} = "none";
    $known_hosts->{$hostname}->{timestamp} = "none";
    $shmkh->shunlock(LOCK_EX); 
    return;  
}

sub update_known_hosts_entry {
    my ($hostname, $status, $passwd, $timestamp) = @_;
    my ($Sekunden, $Minuten, $Stunden, $Monatstag, $Monat,
    $Jahr, $Wochentag, $Jahrestag, $Sommerzeit) = localtime(time);
    $Stunden = $Stunden < 10 ? $Stunden = "0".$Stunden : $Stunden;
    $Minuten = $Minuten < 10 ? $Minuten = "0".$Minuten : $Minuten;
    $Sekunden = $Sekunden < 10 ? $Sekunden = "0".$Sekunden : $Sekunden;
    $Monat+=1;
    $Monat = $Monat < 10 ? $Monat = "0".$Monat : $Monat;
    $Monatstag = $Monatstag < 10 ? $Monatstag = "0".$Monatstag : $Monatstag;
    $Jahr+=1900;
    my $t = "$Jahr$Monat$Monatstag$Stunden$Minuten$Sekunden";

    $shmkh->shlock(LOCK_EX);
    if($status) {
        $known_hosts->{$hostname}->{status} = $status;
    }
    if($passwd) {
        $known_hosts->{$hostname}->{passwd} = $passwd;
    }
    $known_hosts->{$hostname}->{timestamp} = $t;
    $shmkh->shunlock(LOCK_EX); 
    return;  
}



#==== MAIN = main ==============================================================

#  parse commandline options
Getopt::Long::Configure( "bundling" );
GetOptions("h|help" => \&usage,
           "c|config=s" => \$cfg_file,
           "f|foreground" => \$foreground,
           "v|verbose+" => \$verbose,
           );

#  read and set config parameters
&read_configfile;
&check_cmdline_param ;
&check_pid;

$SIG{CHLD} = 'IGNORE';

# restart daemon log file
if(-e $log_file ) { unlink $log_file }
daemon_log("started!");

# Just fork, if we"re not in foreground mode
if( ! $foreground ) { $pid = fork(); }
else { $pid = $$; }

# Do something useful - put our PID into the pid_file
if( 0 != $pid ) {
    open( LOCK_FILE, ">$pid_file" );
    print LOCK_FILE "$pid\n";
    close( LOCK_FILE );
    if( !$foreground ) { exit( 0 ) };
}

# detect own ip, port and address(= ip:port)
 


# setup xml parser
$xml = new XML::Simple();

# create cipher object
$bus_cipher = &create_ciphering($bus_passwd);
$bus_address = "$bus_ip:$bus_port";

# create reading and writing vectors
my $rbits = my $wbits = my $ebits = "";

# open the bus socket
if($bus_activ eq "on") {
    $bus = IO::Socket::INET->new(LocalPort => $bus_port,
            Type => SOCK_STREAM,
            Reuse => 1,
            Listen => 20,
            ) or die "kann kein TCP-Server an Port $bus_port sein: $@\n";
    vec($rbits, fileno $bus, 1) = 1;
    vec($wbits, fileno $bus, 1) = 1;
    print "start bus at $bus_ip:$bus_port\n";        
}

# füge den bus zu known_hosts hinzu
&create_known_hosts_entry($bus_address);
&update_known_hosts_entry($bus_address, "bus", $bus_passwd);


while(1) {
    my $nf = select($rbits, $wbits, undef, undef);
    # error handling
    if($nf < 0 ) { 
    }

    # something is coming in 
    if(vec $rbits, fileno $bus, 1 ) {
        my $client = $bus->accept();
        my $other_end = getpeername($client);
        if(not defined $other_end) {
            daemon_log("Gegenstelle konnte nicht identifiziert werden: $!\n");
        } else {
            my ($port, $iaddr) = unpack_sockaddr_in($other_end);
            my $actual_ip = inet_ntoa($iaddr);
            daemon_log("\naccept client from $actual_ip\n", 5);
            #my $in_msg = <$client>;
            my $in_msg = &read_from_socket($client);
            if(defined $in_msg){
                &activating_child($in_msg, $actual_ip);
            } else {
                daemon_log("cannot read from $actual_ip\n",1);
            }
        }
        close($client);        
    }

    # something is going out
    if(vec $wbits, fileno $bus, 1){
        
    }
}


