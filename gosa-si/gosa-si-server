#!/usr/bin/perl
#===============================================================================
#
#         FILE:  gosa-sd
#
#        USAGE:  ./gosa-sd
#
#  DESCRIPTION:
#
#      OPTIONS:  ---
# REQUIREMENTS:  libconfig-inifiles-perl libcrypt-rijndael-perl libxml-simple-perl 
#                libdata-dumper-simple-perl libdbd-sqlite3-perl libnet-ldap-perl
#                libpoe-perl
#         BUGS:  ---
#        NOTES:
#       AUTHOR:   (Andreas Rettenberger), <rettenberger@gonicus.de>
#      COMPANY:
#      VERSION:  1.0
#      CREATED:  12.09.2007 08:54:41 CEST
#     REVISION:  ---
#===============================================================================

use strict;
use warnings;
use Getopt::Long;
use Config::IniFiles;
use POSIX;
use Time::HiRes qw( gettimeofday );

use Fcntl;
use IO::Socket::INET;
use IO::Handle;
use IO::Select;
use Symbol qw(qualify_to_ref);
use Crypt::Rijndael;
use MIME::Base64;
use Digest::MD5  qw(md5 md5_hex md5_base64);
use XML::Simple;
use Data::Dumper;
use Sys::Syslog qw( :DEFAULT setlogsock);
use Cwd;
use File::Spec;
use GOSA::GosaSupportDaemon;
use GOSA::DBsqlite;
use POE qw(Component::Server::TCP);

my $modules_path = "/usr/lib/gosa-si/modules";
use lib "/usr/lib/gosa-si/modules";

my (%cfg_defaults, $foreground, $verbose, $ping_timeout);
my ($bus, $msg_to_bus, $bus_cipher);
my ($server, $server_mac_address, $server_events);
my ($gosa_server, $job_queue_timeout, $job_queue_table_name, $job_queue_file_name,$job_queue_loop_delay);
my ($known_modules, $known_clients_file_name, $known_server_file_name);
my ($max_clients);
my ($pid_file, $procid, $pid, $log_file);
my (%free_child, %busy_child, $child_max, $child_min, %child_alive_time, $child_timeout);
my ($arp_activ, $arp_fifo, $arp_fifo_path);

# variables declared in config file are always set to 'our'
our (%cfg_defaults, $log_file, $pid_file, 
    $bus_activ, $bus_passwd, $bus_ip, $bus_port,
    $server_activ, $server_ip, $server_port, $server_passwd, $max_clients,
    $arp_activ, $arp_fifo_path,
    $gosa_activ, $gosa_passwd, $gosa_ip, $gosa_port, $gosa_timeout,
);

# additional variable which should be globaly accessable
our $xml;
our $server_address;
our $bus_address;
our $gosa_address;
our $no_bus;
our $no_arp;
our $verbose;
our $forground;
our $cfg_file;

# specifies the verbosity of the daemon_log
$verbose = 0 ;

# if foreground is not null, script will be not forked to background
$foreground = 0 ;

# specifies the timeout seconds while checking the online status of a registrating client
$ping_timeout = 5;

$no_bus = 0;

$no_arp = 0;

# name of table for storing gosa jobs
our $job_queue_table_name = 'jobs';
our $job_db;

# holds all other gosa-sd as well as the gosa-sd-bus
our $known_server_db;

# holds all registrated clients
our $known_clients_db;

%cfg_defaults =
("general" =>
    {"log_file" => [\$log_file, "/var/run/".$0.".log"],
    "pid_file" => [\$pid_file, "/var/run/".$0.".pid"],
    "child_max" => [\$child_max, 10],
    "child_min" => [\$child_min, 3],
    "child_timeout" => [\$child_timeout, 180],
    "job_queue_timeout" => [\$job_queue_timeout, undef],
    "job_queue_file_name" => [\$job_queue_file_name, '/var/lib/gosa-si/jobs.db'],
    "job_queue_loop_delay" => [\$job_queue_loop_delay, 3],
    "known_clients_file_name" => [\$known_clients_file_name, '/var/lib/gosa-si/known_clients.db' ],
    "known_server_file_name" => [\$known_server_file_name, '/var/lib/gosa-si/known_server.db'],
   },
"bus" =>
    {"bus_activ" => [\$bus_activ, "on"],
    "bus_passwd" => [\$bus_passwd, ""],
    "bus_ip" => [\$bus_ip, "0.0.0.0"],
    "bus_port" => [\$bus_port, "20080"],
    },
"server" =>
    {"server_activ" => [\$server_activ, "on"],
    "server_ip" => [\$server_ip, "0.0.0.0"],
    "server_port" => [\$server_port, "20081"],
    "server_passwd" => [\$server_passwd, ""],
    "max_clients" => [\$max_clients, 100],
    },
"arp" =>
    {"arp_activ" => [\$arp_activ, "on"],
    "arp_fifo_path" => [\$arp_fifo_path, "/var/run/gosa-si/arp-notify"],
    },
"gosa" =>
    {"gosa_activ" => [\$gosa_activ, "on"],
    "gosa_ip" => [\$gosa_ip, "0.0.0.0"],
    "gosa_port" => [\$gosa_port, "20082"],
    "gosa_passwd" => [\$gosa_passwd, "none"],
    },
    );


#===  FUNCTION  ================================================================
#         NAME:  usage
#   PARAMETERS:  nothing
#      RETURNS:  nothing
#  DESCRIPTION:  print out usage text to STDERR
#===============================================================================
sub usage {
    print STDERR << "EOF" ;
usage: $0 [-hvf] [-c config]

           -h        : this (help) message
           -c <file> : config file
           -f        : foreground, process will not be forked to background
           -v        : be verbose (multiple to increase verbosity)
           -no-bus   : starts $0 without connection to bus
           -no-arp   : starts $0 without connection to arp module
 
EOF
    print "\n" ;
}


#===  FUNCTION  ================================================================
#         NAME:  read_configfile
#   PARAMETERS:  cfg_file - string -
#      RETURNS:  nothing
#  DESCRIPTION:  read cfg_file and set variables
#===============================================================================
sub read_configfile {
    my $cfg;
    if( defined( $cfg_file) && ( length($cfg_file) > 0 )) {
        if( -r $cfg_file ) {
            $cfg = Config::IniFiles->new( -file => $cfg_file );
        } else {
            print STDERR "Couldn't read config file!\n";
        }
    } else {
        $cfg = Config::IniFiles->new() ;
    }
    foreach my $section (keys %cfg_defaults) {
        foreach my $param (keys %{$cfg_defaults{ $section }}) {
            my $pinfo = $cfg_defaults{ $section }{ $param };
            ${@$pinfo[ 0 ]} = $cfg->val( $section, $param, @$pinfo[ 1 ] );
        }
    }
}


#===  FUNCTION  ================================================================
#         NAME:  logging
#   PARAMETERS:  level - string - default 'info'
#                msg - string -
#                facility - string - default 'LOG_DAEMON'
#      RETURNS:  nothing
#  DESCRIPTION:  function for logging
#===============================================================================
sub daemon_log {
    # log into log_file
    my( $msg, $level ) = @_;
    if(not defined $msg) { return }
    if(not defined $level) { $level = 1 }
    if(defined $log_file){
        open(LOG_HANDLE, ">>$log_file");
        if(not defined open( LOG_HANDLE, ">>$log_file" )) {
            print STDERR "cannot open $log_file: $!";
            return }
            chomp($msg);
            if($level <= $verbose){
                my ($seconds, $minutes, $hours, $monthday, $month,
                        $year, $weekday, $yearday, $sommertime) = localtime(time);
                $hours = $hours < 10 ? $hours = "0".$hours : $hours;
                $minutes = $minutes < 10 ? $minutes = "0".$minutes : $minutes;
                $seconds = $seconds < 10 ? $seconds = "0".$seconds : $seconds;
                my @monthnames = ("Jan", "Feb", "Mar", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec");
                $month = $monthnames[$month];
                $monthday = $monthday < 10 ? $monthday = "0".$monthday : $monthday;
                $year+=1900;
                my $name = $0;
                $name =~ s/\.\///;

                my $log_msg = "$month $monthday $hours:$minutes:$seconds $name $msg\n";
                print LOG_HANDLE $log_msg;
                if( $foreground ) { 
                    print STDERR $log_msg;
                }
            }
        close( LOG_HANDLE );
    }
#log into syslog
#    my ($msg, $level, $facility) = @_;
#    if(not defined $msg) {return}
#    if(not defined $level) {$level = "info"}
#    if(not defined $facility) {$facility = "LOG_DAEMON"}
#    openlog($0, "pid,cons,", $facility);
#    syslog($level, $msg);
#    closelog;
#    return;
}


#===  FUNCTION  ================================================================
#         NAME:  check_cmdline_param
#   PARAMETERS:  nothing
#      RETURNS:  nothing
#  DESCRIPTION:  validates commandline parameter
#===============================================================================
sub check_cmdline_param () {
    my $err_config;
    my $err_counter = 0;
	if(not defined($cfg_file)) {
		$cfg_file = "/etc/gosa-si/server.conf";
		if(! -r $cfg_file) {
			$err_config = "please specify a config file";
			$err_counter += 1;
		}
    }
    if( $err_counter > 0 ) {
        &usage( "", 1 );
        if( defined( $err_config)) { print STDERR "$err_config\n"}
        print STDERR "\n";
        exit( -1 );
    }
}


#===  FUNCTION  ================================================================
#         NAME:  check_pid
#   PARAMETERS:  nothing
#      RETURNS:  nothing
#  DESCRIPTION:  handels pid processing
#===============================================================================
sub check_pid {
    $pid = -1;
    # Check, if we are already running
    if( open(LOCK_FILE, "<$pid_file") ) {
        $pid = <LOCK_FILE>;
        if( defined $pid ) {
            chomp( $pid );
            if( -f "/proc/$pid/stat" ) {
                my($stat) = `cat /proc/$pid/stat` =~ m/$pid \((.+)\).*/;
                if( $0 eq $stat ) {
                    close( LOCK_FILE );
                    exit -1;
                }
            }
        }
        close( LOCK_FILE );
        unlink( $pid_file );
    }

    # create a syslog msg if it is not to possible to open PID file
    if (not sysopen(LOCK_FILE, $pid_file, O_WRONLY|O_CREAT|O_EXCL, 0644)) {
        my($msg) = "Couldn't obtain lockfile '$pid_file' ";
        if (open(LOCK_FILE, '<', $pid_file)
                && ($pid = <LOCK_FILE>))
        {
            chomp($pid);
            $msg .= "(PID $pid)\n";
        } else {
            $msg .= "(unable to read PID)\n";
        }
        if( ! ($foreground) ) {
            openlog( $0, "cons,pid", "daemon" );
            syslog( "warning", $msg );
            closelog();
        }
        else {
            print( STDERR " $msg " );
        }
        exit( -1 );
    }
}

#===  FUNCTION  ================================================================
#         NAME:  import_modules
#   PARAMETERS:  module_path - string - abs. path to the directory the modules 
#                are stored
#      RETURNS:  nothing
#  DESCRIPTION:  each file in module_path which ends with '.pm' is imported by 
#                "require 'file';"
#===============================================================================
sub import_modules {
    daemon_log(" ", 1);

    if (not -e $modules_path) {
        daemon_log("ERROR: cannot find directory or directory is not readable: $modules_path", 1);   
    }

    opendir (DIR, $modules_path) or die "ERROR while loading modules from directory $modules_path : $!\n";
    while (defined (my $file = readdir (DIR))) {
        if (not $file =~ /(\S*?).pm$/) {
            next;
        }

        if( $no_arp > 0 ) {
            if( $file =~ /ArpHandler.pm/ ) {
                next;
            }
        } 
        eval { require $file; };
        if ($@) {
            daemon_log("ERROR: gosa-si-server could not load module $file", 1);
            daemon_log("$@", 5);
        } else {
            my $mod_name = $1;
            my $info = eval($mod_name.'::get_module_info()');
            my ($input_address, $input_key, $input, $input_active, $input_type) = @{$info};
            $known_modules->{$mod_name} = $info;

            daemon_log("module $mod_name loaded", 1);
        }
    }   

    # for debugging
    #while ( my ($module, $tag_hash) = each(%$known_modules)) {
    #    print "\tmodule: $module"."\n";   
    #    print "\ttags: ".join(", ", keys(%$tag_hash))."\n";
    #}
    close (DIR);
}


#===  FUNCTION  ================================================================
#         NAME:  sig_int_handler
#   PARAMETERS:  signal - string - signal arose from system
#      RETURNS:  noting
#  DESCRIPTION:  handels tasks to be done befor signal becomes active
#===============================================================================
sub sig_int_handler {
    my ($signal) = @_;

    daemon_log("shutting down gosa-si-server", 1);
    exit(1);
}
$SIG{INT} = \&sig_int_handler;


#===  FUNCTION  ================================================================
#         NAME:  create_known_client
#   PARAMETERS:  hostname - string - key for the hash known_clients
#      RETURNS:  nothing
#  DESCRIPTION:  creates a dummy entry for hostname in known_clients
#===============================================================================
sub create_known_client {
    my ($hostname) = @_;

    my $entry = { table=>'known_clients',
        hostname=>$hostname,
        status=>'none',
        hostkey=>'none',
        timestamp=>'none',
        macaddress=>'none',
        events=>'none',
    };
    my $res = $known_clients_db->add_dbentry($entry);
    if ($res > 0) {
        daemon_log("ERROR: cannot add entry to known_clients.db: $res", 1);
    }

    return;  
}

sub client_input {
	my ($heap,$input,$wheel) = @_[HEAP, ARG0, ARG1];

    daemon_log("Incoming msg:\n$input\n", 8);

	######################################
	# forward msg to all imported modules 
	no strict "refs";
	my $answer;
	my %act_modules = %$known_modules;
	while( my ($module, $info) = each(%act_modules)) {
		daemon_log("Processing module ".$module, 3);
		my $tmp = &{ $module."::process_incoming_msg" }($input.".".$heap->{remote_ip}."\n");
		if (defined $tmp) {
			$answer = $tmp;
            daemon_log("Got answer from module ".$module.": \n".$answer,8);
		}
	}        
	daemon_log("processing of msg finished", 5);

	if (defined $answer) {
		$heap->{client}->put($answer);
	} else {
		$heap->{client}->put("done\n");
	}
}

sub trigger_db_loop {
	my ($kernel) = $_[KERNEL];
	$kernel->delay_set('watch_for_new_jobs',3);
}

sub watch_for_new_jobs {
	my ($kernel,$heap) = @_[KERNEL, HEAP];

	# check gosa job queue for jobs with executable timestamp
    my $timestamp = &get_time();

    my $sql_statement = "SELECT * FROM ".$job_queue_table_name.
        " WHERE status='waiting' AND timestamp<'$timestamp'";

	my $res = $job_db->select_dbentry( $sql_statement );

	while( my ($id, $hit) = each %{$res} ) {         

		my $jobdb_id = $hit->{id};
		my $macaddress = $hit->{macaddress};
		my $job_msg_hash = &transform_msg2hash($hit->{xmlmessage});
		my $out_msg_hash = $job_msg_hash;
        my $sql_statement = "SELECT * FROM known_clients WHERE macaddress='$macaddress'";
		my $res_hash = $known_clients_db->select_dbentry( $sql_statement );
		# expect macaddress is unique!!!!!!
		my $target = $res_hash->{1}->{hostname};

		if (not defined $target) {
			&daemon_log("ERROR: no host found for mac address: $job_msg_hash->{mac}[0]", 1);
			&daemon_log("xml message: $hit->{xmlmessage}", 5);
            my $sql_statement = "UPDATE $job_queue_table_name ".
                "SET status='error', result='no host found for mac address' ".
                "WHERE id='$jobdb_id'";
			my $res = $job_db->update_dbentry($sql_statement);
			next;
		}

		# add target
		&add_content2xml_hash($out_msg_hash, "target", $target);

		# add new header
		my $out_header = $job_msg_hash->{header}[0];
		$out_header =~ s/job_/gosa_/;
		delete $out_msg_hash->{header};
		&add_content2xml_hash($out_msg_hash, "header", $out_header);

		# add sqlite_id 
		&add_content2xml_hash($out_msg_hash, "jobdb_id", $jobdb_id); 

		my $out_msg = &create_xml_string($out_msg_hash);

		# encrypt msg as a GosaPackage module
		my $cipher = &create_ciphering($gosa_passwd);
		my $crypted_out_msg = &encrypt_msg($out_msg, $cipher);

		my $error = &send_msg_hash2address($out_msg_hash, "$gosa_ip:$gosa_port", $gosa_passwd);

		if ($error == 0) {
			my $sql_statement = "UPDATE $job_queue_table_name ".
                "SET status='processing', targettag='$target' ".
                "WHERE id='$jobdb_id'";
			my $res = $job_db->update_dbentry($sql_statement);
		} else {
            my $sql_statement = "UPDATE $job_queue_table_name ".
                "SET status='error' ".
                "WHERE id='$jobdb_id'";
			my $res = $job_db->update_dbentry($sql_statement);
		}
	}

	$kernel->delay_set('watch_for_new_jobs',3);
}


#==== MAIN = main ==============================================================
#  parse commandline options
Getopt::Long::Configure( "bundling" );
GetOptions("h|help" => \&usage,
        "c|config=s" => \$cfg_file,
        "f|foreground" => \$foreground,
        "v|verbose+" => \$verbose,
        "no-bus+" => \$no_bus,
        "no-arp+" => \$no_arp,
           );

#  read and set config parameters
&check_cmdline_param ;
&read_configfile;
&check_pid;

$SIG{CHLD} = 'IGNORE';

# forward error messages to logfile
if( ! $foreground ) {
    open(STDERR, '>>', $log_file);
    open(STDOUT, '>>', $log_file);
}

# Just fork, if we are not in foreground mode
if( ! $foreground ) { 
    chdir '/'                 or die "Can't chdir to /: $!";
    $pid = fork;
    setsid                    or die "Can't start a new session: $!";
    umask 0;
} else { 
    $pid = $$; 
}

# Do something useful - put our PID into the pid_file
if( 0 != $pid ) {
    open( LOCK_FILE, ">$pid_file" );
    print LOCK_FILE "$pid\n";
    close( LOCK_FILE );
    if( !$foreground ) { 
        exit( 0 ) 
    };
}

daemon_log(" ", 1);
daemon_log("$0 started!", 1);

# delete old DBsqlite lock files
system('rm -f /tmp/gosa_si_lock*');

# connect to gosa-si job queue
my @job_col_names = ("id", "timestamp", "status", "result", "headertag", "targettag", "xmlmessage", "macaddress");
$job_db = GOSA::DBsqlite->new($job_queue_file_name);
$job_db->create_table('jobs', \@job_col_names);

# connect to known_clients_db
my @clients_col_names = ('hostname', 'status', 'hostkey', 'timestamp', 'macaddress', 'events');
$known_clients_db = GOSA::DBsqlite->new($known_clients_file_name);
$known_clients_db->create_table('known_clients', \@clients_col_names);

# connect to known_server_db
my @server_col_names = ('hostname', 'status', 'hostkey', 'timestamp');
$known_server_db = GOSA::DBsqlite->new($known_server_file_name);
$known_server_db->create_table('known_server', \@server_col_names);

# import all modules
&import_modules;

# check wether all modules are gosa-si valid passwd check

# create session for repeatedly checking the job queue for jobs
POE::Session->create
(
	inline_states => {
		_start => \&trigger_db_loop,
		watch_for_new_jobs => \&watch_for_new_jobs,
	}
);

# create socket for incoming xml messages
POE::Component::Server::TCP->new
(
	Port => $server_port,
	ClientInput => \&client_input,
    Concurrency => 10,
);
daemon_log("start socket for incoming xml messages at port '$server_port' ", 1);

POE::Kernel->run();
exit;

